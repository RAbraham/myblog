{
  
    
        "post0": {
            "title": "A toy Datalog interpreter using Ohm and Glue.",
            "content": "Objective . This post shows you how to create a toy Datalog, a laughably incomplete subset of the Datalog language, using an Ohm parser for syntax and a Glue parser for the semantics. The final output is a Python program. . Motivation . I think the time has come for me to explore creating domain specific languages(DSLs)(raj: link) to build software systems. I feel the benefits are: . write less code. I hope to generate the required code from the DSL code | write executable code in that DSL that looks very similar to what an end user/domain expert would understand. Almost like writing English with some structure so that it can be executed. This will allow us to have great communication with domain experts/end users very early in the project preventing miscommunication errors. | Capture the business rules/business workflows at the level of the DSLs. This will allow me to easily change the implementation underneath without having to change the DSL code that captures the complex business logic. (raj: give example and elaborate) | . I hope to write a bigger post later explaining why I think DSLs are something worth exploring(raj: link to dsl motivation post when ready) . Problem Statement . I have a library in Python, called mercylog(raj: link) that is like Datalog. In this post, I want to take actual Datalog code and compile it to Python code which has mercylog statements. Let’s go further into what that means. . I’m first going to show how to express the example in SQL as all of us are familiar with it. Imagine a database with tables parent, man and woman. . CREATE TABLE parent ( name varchar, child varchar ); CREATE TABLE man ( name varchar ); CREATE TABLE woman ( name varchar ); INSERT INTO parent (name, child) VALUES (&#39;abe&#39;, &#39;bob&#39;), (&#39;abby&#39;, &#39;bob&#39;), (&#39;bob&#39;, &#39;carl&#39;), (&#39;bob&#39;, &#39;connor&#39;), (&#39;beatrice&#39;, &#39;carl&#39;); INSERT INTO man(name) VALUES (&#39;abe&#39;), (&#39;bob&#39;); INSERT INTO woman(name) VALUES (&#39;abby&#39;), (&#39;beatrice&#39;); /* Query. Find Fathers */ select man.name as father, parent.child from man inner join parent ON man.name = parent.name; /* Pasting the query result here as well */ name child -- bob carl bob connor abe bob . Now, I really like a language called Datalog(raj: link to datalog wiki and your article explaining Datalog). It’s an alternative to SQL. I even wrote a prototype Python library named mercylog(raj: link to mercylog) to be able to execute Datalog like programs in Python. . Let’s translate the above SQL to a simple variant of Datalog. . parent(abe, bob). parent(abby, bob). parent(bob, carl). parent(bob, connor). parent(beatrice, carl). man(abe). man(bob). woman(abby). woman(beatrice). &lt;=========== This and above are facts father(X, Y) :- man(X), parent(X, Y). &lt;============ This is a rule father(X, Y). &lt;============= This is my query. Should be same result as SQL X Y -- bob carl bob connor abe bob . In Datalog, rows in a table are called facts. X and Y are special logic variables which are different from our regular Python variables(check raj: your introductory Datalog post). parent, man, woman are called relations just as in regular databases. Code is written as rules. You can read the rule above as ‘X is a father of Y if X is man and X is the parent of Y’. The query is find me father and child combinations i.e. father(X, Y) . Note the schema creation step and explicit columns names(i.e. name, child for parent) are missing in this simplistic example of a Datalog variant(there are many of them). This is not saying that oh look, Datalog has so less code than SQL so it’s better. In fact the opposite, I want explicit schema creation etc. in Datalog but that’s another project(or checkout logica. raj: link to logica). . Now, I have a prototype Python library called mercylog. Similar code there would be . from mercylog import R, V, and_, db # Some mercylog helper functions to define variables(V) and Relations(R) X = V.X Y = V.Y parent = R.parent man = R.man woman = R.woman father = R.father # Let&#39;s define the data and rules and query in a single list. facts_rules_query = [ parent(&quot;abe&quot;, &quot;bob&quot;), parent(&quot;abby&quot;, &quot;bob&quot;), parent(&quot;bob&quot;, &quot;carl&quot;), parent(&quot;bob&quot;, &quot;connor&quot;), parent(&quot;beatrice&quot;, &quot;carl&quot;), man(&quot;abe&quot;), man(&quot;bob&quot;), woman(&quot;abby&quot;), woman(&quot;beatrice&quot;), father(X,Y) &lt;&lt; and_(man(X), parent(X, Y)), # rule father(X, Y), # query ] ds = db() # Create an in memory database result = ds(facts_rules_query) # Execute the query print(result.df()) # Result of above print statement X Y 0 bob connor 1 bob carl 2 abe bob . Compiling . The two ‘simple’ stages of creating a compiler are: . a) Creating a Parse Tree: writing a grammar to take raw text and convert that into a parse tree(raj: https://en.wikipedia.org/wiki/Parse_tree). (raj: Also put a picture of parse tree maybe even the one from https://en.wikipedia.org/wiki/Parse_tree, directly in the post). For this, we will use Ohm(raj: link) . b) Assigning Semantics to Parse Tree: Taking the parse tree from the above phase and assigning some meaning to it. i.e. generating code that executes. In our case, we’ll be generating Python code. We could use Ohm for this too but I’ll use a tool called Glue(raj: link) created by Paul Tarvydas . NOTE: Glue is very very much a prototype. It can fail across many edge cases. If this interests you, Paul is looking for programmers who can help him build out his vision. . Creating a Parse Tree . Alright, time for the meat. We build the grammar for our toy Datalog. Ohm has an excellent grammar editor(raj: link ohm editor) which allows one to write a grammar, test it with examples and see the ‘concrete syntax tree’ i.e. how a concrete example of Datalog code breaks out into a parse tree. . (raj: Screenshot of Ohm Editor) . Let’s start with the smallest Ohm grammar . datalog { Program = Statement+ } . This is just saying that my Datalog code is a Program with one or more ‘Statement’s. The + indicates one or more. . What’s a Statement? Well, in the simplest case, we have a fact, e.g. parent(abe, bob). and then we have a rule e.g. father (X, Y) :- man(X), parent(X, Y).. I see a sub pattern as relation (Variable1, Variable2). I’ll call this a Clause and then I’ll worry later what’s in it. So the rule becomes Clause :- Clause, Clause. or even Clause :- Clause, Clause, Clause... We have to capture the pattern , Clause 0 or many times. The way we do it in Ohm is like this. . Statement = Clause &quot;.&quot; -- fact | Clause &quot;:-&quot; Clause CommaClause* &quot;.&quot; -- rule CommaClause = &quot;,&quot; Clause . (raj: explain if – is a comment for now?) (raj: Excalibur drawing?) . Cool, what’s a Clause? It’s like relation(Variable1, Variable2,..,VariableN). I’m going to worry about the ‘variable’ number of variables later. For now, I’ll call it . Clause = Relation &quot;(&quot; IDList &quot;)&quot; . Ok, What’s Relation? It’s a lower case string e.g. father and it has to start with a lower case letter(Datalog Convention). We need to capture single letter relations e.g a in a(X,Y) or bigger relations e.g. father . Relation = LowerCaseIdent LowerCaseIdent = &quot;a&quot; .. &quot;z&quot; identRest* identRest = &quot;0-9&quot; | &quot;_&quot; | &quot;A&quot; .. &quot;Z&quot; | &quot;a&quot; .. &quot;z&quot; . identRest captures the pattern that the rest of the identifier can can either be a number, underscore or upper case or lower case letters. . Now, IDList. You’ll notice a trend here with CommaClause and IDList. It has the same feeling like designing functions. Often, I’ll write pseudocode on how I want a function to look and I’ll design the subroutines without actually implementing them. Just the subroutine calls. Once I like what I see, I’ll then go ahead and implement each subroutine. It feels similar here. . IDList has the same feel like Clause, doesn’t it? . IDList = ID CommaID* CommaID = &quot;,&quot; ID . An ID is going to be either a literal(or constant) like abe in man(abe) or a variable like X and Y in father(X, Y) . A variable starts with a capital letter as per Datalog convention. . ID = Variable | Literal Variable = CapitalizedIdent Literal = LowerCaseIdent #LowerCaseIdent and identRest were already explained before CapitalizedIdent = &quot;A&quot; .. &quot;Z&quot; identRest* . So there you go, I think that’s it. Let’s see the whole ohm grammar file. . datalog { Program = Statement+ Statement = Clause &quot;.&quot; -- fact | Clause &quot;:-&quot; Clause CommaClause* &quot;.&quot; -- rule Clause = Relation &quot;(&quot; IDList &quot;)&quot; CommaClause = &quot;,&quot; Clause Relation = LowerCaseIdent IDList = ID CommaID* ID = Variable | Literal CommaID = &quot;,&quot; ID Variable = CapitalizedIdent Literal = LowerCaseIdent LowerCaseIdent = &quot;a&quot; .. &quot;z&quot; identRest* CapitalizedIdent = &quot;A&quot; .. &quot;Z&quot; identRest* identRest = &quot;0-9&quot; | &quot;_&quot; | &quot;A&quot; .. &quot;Z&quot; | &quot;a&quot; .. &quot;z&quot; } . Glue . Now that we have the Ohm grammar, it’s time to use it to assign some meaning to the parse tree that it’ll generate from our sample Datalog program. Ohm actually already allows us to do that too. . However, Paul Tarvydas(raj: link) found out that he was writing a lot of boilerplate code and decided to ….. write another DSL for it! It’s called Glue (raj: link). CAUTION: Glue is a prototype and does not cover all edge cases. . The way Glue works is you take all the symbols in your Ohm grammar e.g. Clause, ID and write a corresponding piece of JavaScript code to be generated. Glue also simplifies it in the way that you can just write the string of code(Python in my case) that you want to generate. Let’s start with a dummy example. . Program [@Statement] = [[ $ {Statement} ]] . Here, Program and Statement are from the Ohm grammar above. Since we have multiple statements, we use @ to indicate that. The code to be generated is between [[ and ]] . And we refer to the code with JavScript interpolation code ${} . What is the value of Statement above? Well, it’ll be populated ‘somehow’ by Ohm with the values from the rest of the grammar. . I think the above example was too easy for you :) . Let’s show you what I have to actually do. . If you look at my required Python Mercylog code above, I need to first generate some generic, wrapper like Python code like mercylog import statements and initialization no matter what the Datalog code is to be generated. . from mercylog import R, V, and_, db fb = [ .. statements ..] # refer to facts_rules_query above ds = db() result = ds(fb) print(result.df()) . The way we specify that in Glue is(I’m intentionally ) . Program [@Statement] = [[from mercylog import R, V, and_, db nfb = [ ${Statement} ] nds = db() nresult = ds(fb) nprint(result.df()) ]] . It may not look very clean and Paul may have some way to make improve on this but I just wanted to give you an idea. . We need to escape special characters in Glue. For e.g., I have to use [] for Python but that means something in Glue too so I have to escape it e.g. [ . Where do we get statements from? Well, there was something I didn’t mention before, that it’s time to talk about now. Notice the -- rule and -- fact in our Ohm grammar? . Statement = Clause &quot;.&quot; -- fact | Clause &quot;:-&quot; Clause CommaClause* &quot;.&quot; -- rule . They look like comments but they are called case labels in Ohm. They are a way to specify different execution paths for Glue (actually, for Ohm, which Glue uses underneath). So we have two entries in Glue for Statement, Statement_fact and Statement_rule . Note, that the number of parameters for e.g. Statement_fact match closely with how it’s grammar is specified. Using k in kperiod is just a convention, I think, to indicate that it’s a literal unlike the others. . If it’s a fact, I just have to add it to the list fb. The code containing fb is generated above for Program [@statement]. So I take clause which will be generated later and just add a , to it. For rules, I have to convert Statement_rule to the corresponding mercylog statement i.e. clause1 &lt;&lt; and_ (...) . Statement_fact [clause kperiod] = [[${clause}, n]] Statement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} &lt;&lt; and_(${clause}${commaclause}), n]] . I think the rest of the code follows the same principles explained above. . Here’s the final Glue Code. . Program [@Statement] = [[from mercylog import R, V, and_, db nfb = [ ${Statement} ] nds = db() nresult = ds(fb) nprint(result.df()) ]] Statement_fact [clause kperiod] = [[${clause}, n]] Statement_rule [clause1 kcolondash clause @commaclause kdot] = [[${clause1} &lt;&lt; and_(${clause}${commaclause}), n]] Clause [predicate klpar idlist krpar] = [[${predicate}(${idlist})]] CommaClause [kcomma clause] = [[ ,${clause}]] Relation [lowercaseident] = [[R.${lowercaseident}]] IDList [id @commaid] = [[${id}${commaid}]] ID [id] = [[${id}]] CommaID [kcomma id] = [[ , ${id}]] Variable [capident] = [[V.${capident}]] Literal [lowercaseident] = [[&quot;${lowercaseident}&quot;]] LowerCaseIdent [c @cs] = [[${c}${cs}]] CapitalizedIdent [c @cs] = [[${c}${cs}]] identRest [c] = [[${c}]] . Code Generation . So we have the Ohm and Glue grammars. We can now take a Datalog program and generate Python code. Using the pfr tool (raj: link) which reads an Ohm, Glue file and input source language file, we can generate the Python code. . pfr test.datalog datalog.ohm mercylog.glue &gt; test.py . That generates . from mercylog import R, V, and_, db fb = [ R.parent(&quot;abe&quot;, &quot;bob&quot;), R.parent(&quot;abby&quot;, &quot;bob&quot;), R.parent(&quot;bob&quot;, &quot;carl&quot;), R.parent(&quot;bob&quot;, &quot;connor&quot;), R.parent(&quot;beatrice&quot;, &quot;carl&quot;), R.man(&quot;abe&quot;), R.man(&quot;bob&quot;), R.woman(&quot;abby&quot;), R.woman(&quot;beatrice&quot;), R.father(V.X, V.Y) &lt;&lt; and_(R.man(V.X),R.parent(V.X, V.Y)), R.father(V.X, V.Y), ] ds = db() result = ds(fb) print(result.df()) . Not that it’s not indented properly, nor have I done any optimizations. For e.g. V.X could be refactored to X=V.X like in the Python code showed in the very beginning. But that’s another exercise. . Now to test my code, I have to create a project with mercylog in my dependencies and then do . python test.py . and I’ll see . Y X 0 connor bob 1 bob abe 2 carl bob . Summary . If you think about it, we ‘compiled’ a DSL(Datalog) using two other DSLs(Ohm and Glue). It makes you wonder, can we do everything in DSLs? . Extra. . Ohm has a built-in to express a List of tokens e.g. IDList = ID CommaID* above. (raj: find Ohm built-in). The reason we don’t use it is because Glue does not support it. The side benefit is that I can show you the foundation blocks of PEG. | .",
            "url": "https://rajivabraham.com/myblog/markdown/2021/10/29/dsl-datalog-ohm-glue.html",
            "relUrl": "/markdown/2021/10/29/dsl-datalog-ohm-glue.html",
            "date": " • Oct 29, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://rajivabraham.com/myblog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Introduction to Datalog(Bashlog) in Python.",
            "content": "TLDR: . Datalog is like SQL + Recursion. It’s derivatives have reduced the code base by 50% or more. . Datalog . Today, I would like to explore a constrained language called Datalog. It’s a constrained form of Prolog and may not be as expressive as C++ or Python. But it’s derivatives have been known to reduce the numbers of lines of code down by 50% or more(Overlog, Yedalog). . Let’s get started: . Datalog has a minimalist syntax which I love. Let’s take an example. Suppose our data is about fathers and sons, mothers and daughters. If we had an excel sheet, we would enter the data like: . Father Son Aks Bob Bob Cad Yan Zer . and another excel sheet for mothers and daughters: . Mother Daughter Mary Marla Marla Kay Jane Zanu . In Datalog, we express the same data as(together): . father(&#39;Aks&#39;, &#39;Bob&#39;) father(&#39;Bob&#39;, &#39;Cad&#39;) father(&#39;Yan&#39;, &#39;Zer&#39;) mother(&#39;Mary&#39;, &#39;Marla&#39;) mother(&#39;Marla&#39;, &#39;Kay&#39;) mother(&#39;Jane&#39;, &#39;Zanu&#39;) . Here we are trying to say Aks is the father of ‘Bob’ and ‘Bob’ is the father of ‘Cad’. The datum father(‘Aks’, ‘Bob’) is called a fact i.e. it is true. . So Datalog can be used to express data. Not very interesting so far but a building block. These facts above can also be viewed as the existing state of the system, like we store state in files, or databases. . But that’s not enough. What about code? For Datalog, code are specified as *rules* to be applied declaratively. . Let’s say our program needs to find out who’s a grandfather. We could write a rule like: ‘A person X is the grandfather of Z if X is the father of Y and Y is the father of Z’. In Datalog, this rule is written as: . grandfather(X, Z) :- father(X,Y), father(Y, Z) . The LHS (i.e. grandfather) is known as the head and the RHS after the :- is known as the body . X, Y, Z are special variables called logic variables. They are different from regular variables. They are more used to represent a pattern or to link the head and the body. . To further understand logical variables, consider these two rules: . grandfather(X, Z) :- father(X,Y), father(Y, Z) grandmother(X, Z) :- mother(X,Y), mother(Y, Z) . Here the X, Z and Y used in grandfather are completely different from the X, Y and Z in grandmother. In rules, the variables only make sense in that single rule. So we can reuse the same logic variables in different rules without worrying that they have some logical connection. . The next concept is *queries*. How do we feed input and get back some output. Queries are similar to rules but without a head. . father(X, &#39;Aks&#39;), mother(Z, &#39;Aks&#39;) . we mean, find the mother and father of ‘Aks’ or . father(X, &#39;Raj&#39;), mother(Z, &#39;Raj&#39;) . we mean, find the father and mother of ‘Raj’ . Suppose, we want to say find the mother and father of all the children in the database, we make the query . father(X, Y), mother(Z, Y) . Datalog will link Y for all mother and father facts and find the mothers and fathers for a child. It will not mix up fathers and mothers :) . Now, If you opened a datalog interpreter and fed the above and made the following queries, you would get the results shown after the # sign . father(X,_) # [&#39;Aks&#39;, &#39;Bob&#39;, &#39;Yan&#39;] father(_,X) # [&#39;Bob&#39;, &#39;Cad&#39;, &#39;Zer&#39;] father(X, Y) # [(&#39;Aks&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Cad&#39;), (&#39;Yan&#39;, &#39;Zer&#39;) father(X, &#39;Zer&#39;), father(&#39;Zer&#39;, Y) # [] as there are no facts that match the query grandfather(X, Y) # [(&#39;Aks&#39;, &#39;Cad&#39;)] grandfather(X,_) # [&#39;Aks&#39;] . Here ‘_’ is a special variable indicating that you don’t care for the result. . I was always interested in the Datalog syntax and it’s power. I kept delaying it until I met Bashlog. Because, the syntax of datalog is so simple, it makes it easy to write interpeters for different targets. What Bashlog did was take Datalog syntax and convert it to bash scripts! Because, it used awk(mawk actually), sed, grep, which are tuned for high performance on Unix like platforms, it was incredibly fast in parsing big text files, comparable with all the specialized databases out there. Just Bash Scripts. It blew my mind. So if you are interested in pure Datalog, check out Bashlog . With Bashlog, you can run any bash like command and read that using Bashlog. Imagine there was a file(‘~/data.tsv’) with tab separated values of . Aks Bob Bob Cad Yan Zer . We could read that data like: . facts(F, S) :~ cat ~/data.tsv father(X, Y) :- facts(X, Y) . And then we proceed the same manner like before. What’s awesome is that you can run any Unix command(e.g. ls -l) as long as it returns an output of tab separated values. . But I wanted to use Datalog in my day to day programming. I wanted to see if I could use and leverage Datalog along with Python. Some benefits of Datalog in Python are: . Modularity. How do we abstract out patterns in our rules and facts. | Possible access to exisitng rich source of libraries. | . So I built Mercylog in Python. . So let’s translate the above rules to Mercylog syntax. . Installation . If you are using the Bashlog variant, . then you need Java 8 already installed | . git clone https://github.com/RAbraham/mercylog_tutorial.git cd mercylog_tutorial python3 -m venv venv source venv/bin/activate pip install -r requirements.txt python tutorial.py . That should print . [&#39;Aks&#39;] [&#39;Mary&#39;] . Read below on the explanation and make tweaks if you want and run python tutorial.py again. . Usage . import mercylog m = mercylog.BashlogV1() . # father(&#39;Aks&#39;, &#39;Bob&#39;) # father(&#39;Bob&#39;, &#39;Cad&#39;) # father(&#39;Yan&#39;, &#39;Zer&#39;) # mother(&#39;Mary&#39;, &#39;Marla&#39;) # mother(&#39;Marla&#39;, &#39;Kay&#39;) # mother(&#39;Jane&#39;, &#39;Zanu&#39;) father = m.relation(&#39;father&#39;) mother = m.relation(&#39;mother&#39;) facts = [ father(&#39;Aks&#39;, &#39;Bob&#39;), father(&#39;Bob&#39;, &#39;Cad&#39;), father(&#39;Yan&#39;, &#39;Zer&#39;), mother(&#39;Mary&#39;, &#39;Marla&#39;), mother(&#39;Marla&#39;, &#39;Kay&#39;), mother(&#39;Jane&#39;, &#39;Zanu&#39;), ] . # grandfather(X, Z) :- father(X,Y), father(Y, Z) grandfather = m.relation(&#39;grandfather&#39;) X, Y, Z = m.variables(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;) grandfather(X, Z) &lt;= [father(X, Y), father(Y, Z)] . While in Datalog, you don’t have to explicitly state the variables and the relation, as it is baked in to the language, in our library in Python, we need to (e.g. X, Y, Z and father, grandfather) . Making a query in python has the following syntax . m.run(facts, rules, query) . A concrete example would be: . m.run(facts, rules, grandfather(X, Y)) # which gives [(&#39;Aks&#39;, &#39;Cad&#39;)] m.run(facts, rules, father(X,_)) # [&#39;Aks&#39;, &#39;Bob&#39;, &#39;Yan&#39;] m.run(facts, rules,father(_,X)) # [&#39;Bob&#39;, &#39;Cad&#39;, &#39;Zer&#39;] m.run(facts, rules,father(X, Y)) # [(&#39;Aks&#39;, &#39;Bob&#39;), (&#39;Bob&#39;, &#39;Cad&#39;), (&#39;Yan&#39;, &#39;Zer&#39;) m.run(facts, rules, granfather(X,_)) # [&#39;Aks&#39;] . Creating this DSL in python gives us some unique benefits. For e.g if we had these two relations . paternal_grandfather = m.relation(&#39;paternal_grandfather&#39;) maternal_grandmother = m.relation(&#39;maternal_grandmother&#39;) father = m.relation(&#39;father&#39;) mother = m.relation(&#39;mother&#39;) X, Y, Z = m.variables(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;) rules = [ paternal_grandfather(X, Z) &lt;= [father(X, Y), father(Y, Z)], maternal_grandmother(X, Z) &lt;= [mother(X, Y), mother(Y, Z)] ] . If you notice, the rule for paternal_grandfather and maternal_grandmother are very similar. I could perhaps encapsulate that into a function. I’ll use the word transitive though I believe it is incorrect to use it.. but I don’t know what to call this for now. Rewriting the above code: . def transitive(head, clause): X, Y, Z = m.variables(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;) return head(X, Z) &lt;= [clause(X, Y), clause(Y, Z)] paternal_grandfather = m.relation(&#39;paternal_grandfather&#39;) maternal_grandmother = m.relation(&#39;maternal_grandmother&#39;) father = m.relation(&#39;father&#39;) mother = m.relation(&#39;mother&#39;) rules = [ transitive(paternal_grandfather, father), transitive(maternal_grandmother, mother) ] . In this way, using Python, we have modularized a pattern using the transitive function. . Let’s recap the benefits of Mercylog . Simple Syntax. All you need to know is facts and rules. Because of such simplicity, it is also easy to build compilers for it. | Expressive. Rules give a powerful mechanism | Declarative. Like SQL but more expressive. So we can optimize it’s engines without affecting the code | . I’ll continue to update you with my future learnings! .",
            "url": "https://rajivabraham.com/myblog/markdown/2020/02/16/introducing-mercylog.html",
            "relUrl": "/markdown/2020/02/16/introducing-mercylog.html",
            "date": " • Feb 16, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post by Rajiv",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://rajivabraham.com/myblog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rajivabraham.com/myblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rajivabraham.com/myblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}